[SELinux]

[[Terminology]]
These give a brief introduction to the major components that form the core SELinux infrastructure. 
- Access Vector (AV) : A bit map representing a set of permissions (such as open, read, write).
- Access Vector Cache (AVC) : A component that stores access decisions made by the SELinux Security Server for subsequent use by Object Managers. This allows previous decisions to be retrieved without the overhead of re-computation. Within the core SELinux services there are two Access Vector Caches:
1. A kernel AVC that caches decisions by the Security Server on behalf of kernel based object managers.
2. A userspace AVC built into libselinux that caches decisions when SELinux-aware applications use avc_open(3) with avc_has_perm(3) or avc_has_perm_noaudit(3) function calls. This will save calls to the kernel after first decision has been made. Note that the preferred option is to use the selinux_check_access(3) function as this will utilize the AVC as explained in the Computing Access Decisions (https://github.com/SELinuxProject/selinux-notebook/blob/main/src/computing_access_decisions.md#computing-access-decisions) section.

- Domain : For SELinux this consists of one or more processes associated to the type of component of a Security Context. Type Enforcement rules declared in policy describe how the domain will interact with objects (see Object Class).
- Linux Security Module (LSM): A framework that provides hooks into kernel componets (such as disk and network services) that can be utilized by security modules (e.g., SELinux and SMACK) to perform access control checks.

- Mandatory Access Control : An access control mechanism enforced by the system. This can be achieved by 'hard-wiring' the operating system and applications or via a policy that conforms to a Policy. Examples of policy based MAC are SELinux and SMACK.
- Object Class: Describes a resource such as files, sockets or services. Each 'class' has relevant permissions associated to it such as read, write or export. This allows access to be enforced on the instantiated object by their Object Manager. 

- Object Manager : Userspace and kernel components that are responsible for the labeling, management (e.g., creation, access, destruction) and enforcement of the objects under their control. Object Managers call the Security Server for an access decision based on a source and target Security Context (for SID), an Object Class and a set of permissions (or AVs). The Security Server will base its decision on whether the currently loaded Policy will allow or deny access. An Object Manager may also call the Security Server to compute a new Security Context or SID for an object. 

- Policy : A set of rules determining access rights. In SELinux these rules are generally written in a kernel policy language using either m4(1) macro support (e.g., Reference Policy) or the CIL language. The Policy is then compiled into a binary format for loading into the Security Server. 

- Role Based Access Control : SELinux users are associated to one or more rules, each role may then be associated to one or more Domain types. 

- Role Based 

[[Introduction]]
- SELinux  is the most popular Linux Security Module (LSM) used to isolate and protect system components from one another.
- One question that immediately comes to mind on such a multi-user system is ownership. A use may own, for example, a file. After assigning an owner, the next question to naturally come up is: can a user interact with resource owned by another user? 
- This has led to the development of Access Control, which is a standard used to define permissions on systems. 
- Access Conrol can be divided into two main types: Discretionary Access Control (DAC) and Mandatory Access Control (MAC). 
- Discretionary Access Control is based around owners, where an owner can decide who has access to its resources. DACs are used in all modern day operating systems. For example, POSIX operating systems assign an owner to each file/directory who can decide how users in its group and outside its group can interact with the file. Another example is Windows, NTFS permissions are slightly more complex allowing for overlapping allow and deny permissions, but still follow an owner-centric model. 
- 
