https://elixir.bootlin.com/linux/v6.12.4/source/include/linux/sched.h#L778
https://elixir.bootlin.com/linux/v6.12.4/source/include/linux/sched.h#L99

Process Management
------------------
- most fundamental abstraction in a Unix/Linux system.
- An object code in execution - active, alive, running programs- Processes are more than just assembly language; they consist
  data, resoruces, state, and a virtualized computer.

  we will discuss the fundamentals of the process, from creation to termination.

- Unix took an interesting path, one seldom traveled, separating the creation of a new process from the act of loading
  a new binary image.Although the two tasks are performed in tandem much of the time, the division has allowed a great 
  deal of freedom for experimentation and evolution for each of the tasks. 
- While most operating systems offer a single system call to start up a new program, Unix requires two: a fork and an exec. 


Programs, processes, and Threads
--------------------------------
A binary is compiled, executable code lying dormant on a storage medium such as a disk. Colloquially, we may also use the 
term program; large and significant binaries we might call applications. /bin/pwd and /usr/bin/X11 are both binaries. 

A process is a running program. A process includes the binary image, loaded into memory, but also much more: an instance of 
virtualized memory, kernel resoruces such as open files, a security context such as an associated user, and one or more
threads. 
A thread is the unit of activity inside of a process. Each thread has its own virtualized processor, which includes a stack, 
processor state as resgisters, and an instruction pointer. 

In a single threaded process, the process is the thread. There is one instance of virtualized memory and one virtualized 
processor. 

In a multithreaded process, there are multiple threads. As the virtualization of memory is associated with the process, 
the threads all share the same memory address space.

The Process ID
--------------
- Each process is represented by a unique identifier, the process ID (pid). 
- The pid is guaranteed to be unique at any single point in time. 

The idle process, which is the process that the kernel "runs" when there are no other runnable processes, has the pid 0.
The first process that the kernel executes after booting the system, called the init process, has the pid 1.

Unless the user explicitly tells the kernel what process to run (through the init kernel command-line parameter), 
the kernel has to identify a suitable init process on its own - a rare example where the kernel dictates policy. 
The Linux kernel tried four executables, ih the following order:
* /sbin/init: The preferred and most likely location for the init process.
* /etc/init: Another likely location for the init process.
* /bin/init: A fallback location for the init process.
* /bin/sh: The location of the Bourne shell, which the kernel tried to run if it fails to find an init process.

The first of these processes that exists is executed as the init process. If all four processes fail to execute, 
the Linux kernel halts the system with a panic. 

After the handoff from the kernel, the init process handles the remainer of the boot process. 
Typically, this includes initializing the system, starting various services, and launching a login program.

Process ID Allocation
---------------------
By default, the kernel imposes a maximum process ID value of 32768 (2 ** 16-1). This is for compatiablity 
with older Unix systems, which used signed 16-bit types for process IDs. 
System administrators can set the value higher via /proc/sys/kernel/pid_max, treading a larger pid space for reduced 
compatibility.

The kernel allocates process IDs to processes in a stricly linear fashion. 


=================
man 2 fork
man 2 execve

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    for(size_t j = 0; j < argc; j++)
        printf("argv[%zu]: %s\n", j, argv[j]);
    exit(EXIT_SUCEESS);
}


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char **argv) {
    static char *newargv[] = { NULL, "Opertating System" , " for MSCIT", NULL };
    static char *newenviron[] = { NULL };

    if (argc != 2) {
        fprintf(stderr, "Usage: %s <file-to-execute>\n", argv[0]);
        exit(EXIt_FAILURE);
    }

    newargv[0] = argv[1];
    execve(argv[1], newargv, newenviron);
    perror("execve"); /* execve() returns only on error/*
    exit(EXIT_FAILURE);
}

$cc first.c -o first
$cc second.c - second 
$./second ./first

